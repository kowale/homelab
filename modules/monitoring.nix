{ config, pkgs, ... }:

/*

Prometheus
    Time-series key-value database
    Queries by PromQL
    Pulls from exporters
    Debugging
        prom2json
        promexplorer
        promql-cli
    Altermanager
        karma
        kthxbye
        alertmanager-irc-relay
    Long-term storage
        victoriametrics
        thanos
        mimir

Exporters
    Telegraf (many exporters in one binary)
    Node, systemd, process
    GPU: dcgm
    Storage: smartctl
    Network: tailscalesd, unpoller, mtr
    Heartbeat: ping, blackbox
    Generic: SQL, JSON, script, pushgateway
    Nix? eBPF?

Loki
    Log aggregation
    Query by LogQL
    Tag-based storage
    Promtail collects logs

Tempo
    Trace aggregation
    Query by TraceQL
    Metric -> trace

Grafana
    Connect to Prometheus and Loki
    Declarative dashboards

Pyroscope
    Profiling aggregation

*/

let

  inherit (config.networking) hostName;

  nodeExporter = config.services.prometheus.exporters.node;

  # Consider https://blog.korfuri.fr/posts/2022/11/autogenerated-prometheus-configs-for-multiple-nixos-hosts/

in {

  # Consume alerts from alertmanager
  services.webhook = {
    enable = true;
    hooks = {
      ok = {
        execute-command = "echo";
        response-message = "OK";
      };
      effect = {
        include-command-output-in-response-on-error = true;
        # include-command-output-in-response = true;
        execute-command = let
          effect = pkgs.writeScript "effect" ''
            echo haii
            echo hiii > /tmp/effect
            echo baiii
          '';
        in
          "${effect}";
      };
      alertmanager = {
        execute-command = "echo $(date) > /tmp/alert";
        incoming-payload-content-type = "application/json";
        pass-arguments-to-command = [
          {
            source = "payload";
            name = "externalURL";
          }
          {
            source = "payload";
            name = "alerts.0.status";
          }
          {
            source = "payload";
            name = "alerts.0.annotations.summary";
          }
          {
            source = "payload";
            name = "alerts.0.annotations.description";
          }
        ];
      };
    };
  };

  services.prometheus = {
    enable = true;
    port = 9001;
    listenAddress = "127.0.0.1";

    rules = [
      ""
    ];

    # Send alerts to a webhook
    alertmanager = {
      enable = true;
      configuration = {
        route.receiver = "webhook";
        receivers = [
          {
            name = "webhook";
            webhook_configs = [
              {
                url = "http://127.0.0.1:${toString config.services.webhook.port}/hooks/alertmanager";
              }
            ];
          }
        ];
      };
    };

    scrapeConfigs = [

      {
        job_name = "node";
        static_configs = [{
          targets = [
            "localhost:${toString config.services.prometheus.exporters.node.port}"
          ];
        }];
      }

      {
        job_name = "process";
        static_configs = [{
          targets = [
            "localhost:${toString config.services.prometheus.exporters.process.port}"
          ];
        }];
      }

      {
        job_name = "smartctl";
        static_configs = [{
          targets = [
            "localhost:${toString config.services.prometheus.exporters.smartctl.port}"
          ];
        }];
      }

      {
        job_name = "systemd";
        static_configs = [{
          targets = [
            "localhost:${toString config.services.prometheus.exporters.systemd.port}"
          ];
        }];
      }

    ];
  };

  # node
  # systemd
  # process
  # restic
  # script, json, blackbox
  # smartctl (ssd)
  # scaphandre (energy)
  # wireguard
  # ping, smokeping
  # rtl_433 (for rtl-sdr)
  # mtr (services.mtr-exporter)
  # apcupsd (ups)
  # collectd (many weird things)
  # zfs (is there ext4?)
  services.prometheus.exporters.node = {
    enable = true;
    port = 9002;
    enabledCollectors = [
      "cpu"
      "filesystem"
      "loadavg"
      "systemd"
    ];
  };
  # ntp
  # nvidia dcgm
  # ripe atlas
  # ebpf

  services.prometheus.exporters.systemd.enable = true;
  services.prometheus.exporters.process.enable = true;

  services.prometheus.exporters.smartctl.enable = true;
  services.udev.extraRules = ''
    SUBSYSTEM=="nvme", KERNEL=="nvme[0-9]*", GROUP="disk"
  '';

  services.grafana = {
    enable = true;

    settings = {
      server = {
        #domain = "grafana.${hostName}.local";
        http_addr = "127.0.0.1";
        http_port = 3333;
      };
      "auth.anonymous" = {
        enabled = true;
        org_role = "Editor";
      };
      auth = {
        disable_login_form = true;
        # disable_login = true;
      };
      # https://zach.oglesby.co/2024/02/08/nixos-grafana-tailscale.html
    };

    provision = {
      enable = true;
      datasources.settings.datasources = [
        {
          name = "Prometheus";
          uid = "abcd";
          isDefault = true;
          type = "prometheus";
          url = "http://127.0.0.1:${toString config.services.prometheus.port}";
        }
      ];
      dashboards.settings.providers = [
        { options.path = "/etc/dashboards"; }
      ];
    };
  };

  # Copy ./dashboard/*.json to /etc/dashboards
  environment.etc = with builtins; mapAttrs (
    key: value: {
      target = "dashboards/${key}";
      source = ./. + "/dashboards/${key}";
    }
  ) (readDir ./dashboards);

  networking.firewall.allowedTCPPorts = [
    80 443
    config.services.grafana.settings.server.http_port
    config.services.prometheus.port
    config.services.prometheus.exporters.node.port
    config.services.prometheus.exporters.systemd.port
    config.services.prometheus.exporters.process.port
    config.services.prometheus.exporters.smartctl.port
    config.services.webhook.port
  ];

  networking.extraHosts = ''
    127.0.0.1 grafana.${hostName}.local
    127.0.0.1 prometheus.${hostName}.local
    127.0.0.1 webhook.${hostName}.local
  '';

  services.caddy = {
    enable = true;
    virtualHosts = {


      "grafana.${hostName}.local".extraConfig = ''
        encode gzip
        tls internal
        reverse_proxy http://127.0.0.1:${toString config.services.grafana.settings.server.http_port}
      '';


      "prometheus.${hostName}.local".extraConfig = ''
        encode gzip
        tls internal
        reverse_proxy http://127.0.0.1:${toString config.services.prometheus.port}
      '';


      "webhook.${hostName}.local".extraConfig = ''
        encode gzip
        tls internal
        reverse_proxy http://127.0.0.1:${toString config.services.webhook.port}
      '';


    };
  };
}
